<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Translation Telephone</title>
<script src="https://cdn.jsdelivr.net/npm/diff@7/dist/diff.min.js"></script>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #f4f1ee;
    --surface: #ffffff;
    --primary: #4361ee;
    --primary-hover: #3a56d4;
    --text: #1e1e2f;
    --text-muted: #6b7280;
    --border: #e2e0dc;
    --green: #16a34a;
    --green-bg: #dcfce7;
    --red: #dc2626;
    --red-bg: #fee2e2;
    --radius: 12px;
    --shadow: 0 2px 8px rgba(0,0,0,0.06);
  }

  body {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    padding: 2rem 1rem 4rem;
  }

  h1 {
    text-align: center;
    font-size: 2rem;
    font-weight: 700;
    margin-bottom: 0.25rem;
  }

  .subtitle {
    text-align: center;
    color: var(--text-muted);
    font-size: 0.95rem;
    margin-bottom: 2rem;
  }

  .container {
    max-width: 640px;
    margin: 0 auto;
  }

  /* Input area */
  .input-area {
    background: var(--surface);
    border-radius: var(--radius);
    padding: 1.5rem;
    box-shadow: var(--shadow);
    margin-bottom: 2rem;
  }

  .input-area label {
    display: block;
    font-weight: 600;
    margin-bottom: 0.4rem;
    font-size: 0.9rem;
  }

  .phrase-label-row {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    margin-bottom: 0.4rem;
  }

  .phrase-label-row label {
    margin-bottom: 0;
  }

  .phrase-label-row select {
    font-family: inherit;
    font-size: 0.9rem;
    font-weight: 600;
    padding: 0.2rem 0.4rem;
    border: 2px solid var(--border);
    border-radius: 6px;
    background: var(--surface);
    color: var(--primary);
    cursor: pointer;
    transition: border-color 0.2s;
  }

  .phrase-label-row select:focus {
    outline: none;
    border-color: var(--primary);
  }

  .input-area textarea {
    width: 100%;
    border: 2px solid var(--border);
    border-radius: 8px;
    padding: 0.75rem;
    font-size: 1rem;
    font-family: inherit;
    resize: vertical;
    min-height: 70px;
    transition: border-color 0.2s;
  }

  .input-area textarea:focus {
    outline: none;
    border-color: var(--primary);
  }

  .controls {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-top: 1rem;
    flex-wrap: wrap;
  }

  .slider-group {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex: 1;
    min-width: 200px;
  }

  .slider-group label {
    white-space: nowrap;
    margin-bottom: 0;
    font-size: 0.85rem;
  }

  .slider-group input[type="range"] {
    flex: 1;
    accent-color: var(--primary);
  }

  .slider-group .slider-val {
    font-weight: 700;
    font-size: 1.1rem;
    min-width: 1.5ch;
    text-align: center;
  }

  .btn {
    display: inline-flex;
    align-items: center;
    gap: 0.4rem;
    background: var(--primary);
    color: #fff;
    border: none;
    border-radius: 8px;
    padding: 0.65rem 1.4rem;
    font-size: 0.95rem;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s, opacity 0.2s;
    white-space: nowrap;
  }

  .btn:hover { background: var(--primary-hover); }
  .btn:disabled { opacity: 0.5; cursor: not-allowed; }

  .btn-reset {
    background: transparent;
    color: var(--text-muted);
    border: 2px solid var(--border);
  }
  .btn-reset:hover { background: var(--bg); color: var(--text); border-color: var(--text-muted); }

  /* Chain */
  .chain { display: flex; flex-direction: column; gap: 0; }

  .step {
    position: relative;
    background: var(--surface);
    border-radius: var(--radius);
    padding: 1rem 1.25rem;
    box-shadow: var(--shadow);
    opacity: 0;
    transform: translateY(12px);
    animation: fadeUp 0.4s forwards;
  }

  @keyframes fadeUp {
    to { opacity: 1; transform: translateY(0); }
  }

  .connector {
    display: flex;
    justify-content: center;
    padding: 0.15rem 0;
    color: var(--text-muted);
    font-size: 1.2rem;
    user-select: none;
  }

  .step-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 0.35rem;
  }

  .lang-label {
    font-weight: 700;
    font-size: 0.85rem;
    color: var(--primary);
    text-transform: uppercase;
    letter-spacing: 0.04em;
  }

  .lang-native {
    font-weight: 400;
    text-transform: none;
    color: var(--text-muted);
    letter-spacing: normal;
    margin-left: 0.4rem;
    font-size: 0.82rem;
  }

  .speak-btn {
    background: none;
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 0.25rem 0.5rem;
    cursor: pointer;
    font-size: 1rem;
    line-height: 1;
    transition: border-color 0.2s, background 0.2s;
  }

  .speak-btn:hover { border-color: var(--primary); background: #eef1ff; }
  .speak-btn:disabled { opacity: 0.35; cursor: not-allowed; }

  .step-text {
    font-size: 1.05rem;
    line-height: 1.5;
    word-break: break-word;
  }

  /* Result card */
  .result-card {
    background: var(--surface);
    border-radius: var(--radius);
    padding: 1.5rem;
    box-shadow: var(--shadow);
    opacity: 0;
    transform: translateY(12px);
    animation: fadeUp 0.4s forwards;
  }

  .result-card h2 {
    font-size: 1.1rem;
    margin-bottom: 0.75rem;
  }

  .diff-display {
    font-size: 1.1rem;
    line-height: 1.7;
    margin-bottom: 1rem;
    word-break: break-word;
  }

  .diff-display .added {
    background: var(--green-bg);
    color: var(--green);
    padding: 0.1em 0.2em;
    border-radius: 3px;
    font-weight: 600;
  }

  .diff-display .removed {
    background: var(--red-bg);
    color: var(--red);
    padding: 0.1em 0.2em;
    border-radius: 3px;
    text-decoration: line-through;
    font-weight: 600;
  }

  .similarity {
    display: inline-block;
    font-weight: 700;
    font-size: 1.5rem;
    margin-right: 0.5rem;
  }

  .similarity-label {
    color: var(--text-muted);
    font-size: 0.9rem;
  }

  .copy-btn {
    display: inline-flex;
    align-items: center;
    gap: 0.4rem;
    background: transparent;
    color: var(--text-muted);
    border: 2px solid var(--border);
    border-radius: 8px;
    padding: 0.5rem 1.1rem;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    margin-top: 1rem;
    transition: background 0.2s, color 0.2s, border-color 0.2s;
  }
  .copy-btn:hover { background: var(--bg); color: var(--text); border-color: var(--text-muted); }
  .copy-btn.copied {
    border-color: var(--green);
    color: var(--green);
    background: var(--green-bg);
  }

  .result-actions {
    display: flex;
    gap: 0.6rem;
    flex-wrap: wrap;
    margin-top: 1rem;
  }

  .carousel-wrap {
    margin-top: 1rem;
  }

  .carousel-meta {
    color: var(--text-muted);
    font-size: 0.82rem;
    margin-top: 0.4rem;
    text-align: right;
  }

  .error-msg {
    background: var(--red-bg);
    color: var(--red);
    padding: 0.75rem 1rem;
    border-radius: 8px;
    font-size: 0.9rem;
    margin-top: 1rem;
  }

  .email-row {
    margin-top: 1rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border);
  }

  .email-row label {
    font-size: 0.82rem;
    color: var(--text-muted);
    margin-bottom: 0.35rem;
  }

  .email-input-group {
    display: flex;
    gap: 0.5rem;
    margin-top: 0.35rem;
  }

  .email-input-group input {
    flex: 1;
    border: 2px solid var(--border);
    border-radius: 8px;
    padding: 0.4rem 0.75rem;
    font-size: 0.9rem;
    font-family: inherit;
    transition: border-color 0.2s;
  }

  .email-input-group input:focus {
    outline: none;
    border-color: var(--primary);
  }

  .combo-count {
    margin-top: 0.85rem;
    font-size: 0.82rem;
    color: var(--text-muted);
  }

  .disclaimer {
    text-align: center;
    color: var(--text-muted);
    font-size: 0.8rem;
    font-style: italic;
    margin-bottom: 2rem;
  }

  .visitor-counter {
    text-align: center;
    margin-top: 2rem;
    font-size: 0.85rem;
    color: var(--text-muted);
  }

  .visitor-counter .counter-digits {
    display: inline-flex;
    gap: 2px;
    margin-left: 0.4rem;
    vertical-align: middle;
  }

  .visitor-counter .counter-digits span {
    display: inline-block;
    background: #111;
    color: #0f0;
    font-family: 'Courier New', monospace;
    font-weight: 700;
    font-size: 1rem;
    padding: 0.15rem 0.35rem;
    border-radius: 3px;
    min-width: 1.2rem;
    text-align: center;
  }

  .credit {
    text-align: center;
    color: var(--text-muted);
    font-size: 0.8rem;
    margin-top: 2rem;
  }

  .credit a {
    color: var(--primary);
    text-decoration: none;
  }

  .credit a:hover {
    text-decoration: underline;
  }

  blink {
    animation: oldblink 1s step-end infinite;
  }
  @keyframes oldblink {
    50% { opacity: 0; }
  }

  @media (max-width: 500px) {
    h1 { font-size: 1.5rem; }
    .controls { flex-direction: column; align-items: stretch; }
    .btn { justify-content: center; }
  }
</style>
</head>
<body>

<div class="container">
  <h1>Translation Telephone</h1>
  <p class="subtitle">Pass a phrase through random languages and see what happens.</p>
  <p class="disclaimer">Disclaimer:I don't know what you typed, and I didn't do the translations. If you don't like the results, try again.</p>

  <div class="input-area">
    <div class="phrase-label-row">
      <label for="phrase">Your phrase in</label>
      <select id="startLang"></select>
    </div>
    <textarea id="phrase" placeholder="e.g. The quick brown fox jumps over the lazy dog"></textarea>

    <div class="controls">
      <div class="slider-group">
        <label for="steps">Steps:</label>
        <input type="range" id="steps" min="2" max="25" value="8">
        <span class="slider-val" id="stepsVal">8</span>
      </div>
      <button class="btn" id="goBtn">
        <span id="goBtnText">Start</span>
      </button>
      <button class="btn btn-reset" id="resetBtn" style="display:none">Reset</button>
    </div>

    <div id="emailRow" class="email-row" style="display:none">
      <label for="emailInput">âš¡ Rate limited â€” add your email for 10Ã— more translations:</label>
      <div class="email-input-group">
        <input type="email" id="emailInput" placeholder="you@example.com">
        <button class="btn" id="emailSaveBtn" style="padding:0.4rem 0.9rem;font-size:0.85rem;">Save</button>
      </div>
    </div>

    <div id="comboCount" class="combo-count"></div>
  </div>

  <div id="chain" class="chain"></div>
  <div id="result"></div>
  <div id="error"></div>

  <div class="visitor-counter" id="visitorCounter"></div>
  <p class="credit">Translations powered by <a href="https://mymemory.translated.net/" target="_blank" rel="noopener">MyMemory</a><br>Synonyms powered by <a href="https://www.datamuse.com/api/" target="_blank" rel="noopener">Datamuse</a><br>Built with <a href="https://www.cursor.com/" target="_blank" rel="noopener">Cursor</a></p>
</div>

<script>
const LANGUAGES = [
  { code: "en", name: "English",     native: "English" },
  { code: "ar", name: "Arabic",      native: "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©" },
  { code: "bg", name: "Bulgarian",   native: "Ð‘ÑŠÐ»Ð³Ð°Ñ€ÑÐºÐ¸" },
  { code: "bn", name: "Bengali",     native: "à¦¬à¦¾à¦‚à¦²à¦¾" },
  { code: "cs", name: "Czech",       native: "ÄŒeÅ¡tina" },
  { code: "da", name: "Danish",      native: "Dansk" },
  { code: "de", name: "German",      native: "Deutsch" },
  { code: "el", name: "Greek",       native: "Î•Î»Î»Î·Î½Î¹ÎºÎ¬" },
  { code: "es", name: "Spanish",     native: "EspaÃ±ol" },
  { code: "et", name: "Estonian",    native: "Eesti" },
  { code: "fa", name: "Persian",     native: "ÙØ§Ø±Ø³ÛŒ" },
  { code: "fi", name: "Finnish",     native: "Suomi" },
  { code: "fr", name: "French",      native: "FranÃ§ais" },
  { code: "ga", name: "Irish",       native: "Gaeilge" },
  { code: "he", name: "Hebrew",      native: "×¢×‘×¨×™×ª" },
  { code: "hi", name: "Hindi",       native: "à¤¹à¤¿à¤¨à¥à¤¦à¥€" },
  { code: "hr", name: "Croatian",    native: "Hrvatski" },
  { code: "hu", name: "Hungarian",   native: "Magyar" },
  { code: "id", name: "Indonesian",  native: "Bahasa Indonesia" },
  { code: "it", name: "Italian",     native: "Italiano" },
  { code: "ja", name: "Japanese",    native: "æ—¥æœ¬èªž" },
  { code: "ko", name: "Korean",      native: "í•œêµ­ì–´" },
  { code: "lt", name: "Lithuanian",  native: "LietuviÅ³" },
  { code: "lv", name: "Latvian",     native: "LatvieÅ¡u" },
  { code: "ms", name: "Malay",       native: "Bahasa Melayu" },
  { code: "nl", name: "Dutch",       native: "Nederlands" },
  { code: "no", name: "Norwegian",   native: "Norsk" },
  { code: "pl", name: "Polish",      native: "Polski" },
  { code: "pt", name: "Portuguese",  native: "PortuguÃªs" },
  { code: "ro", name: "Romanian",    native: "RomÃ¢nÄƒ" },
  { code: "ru", name: "Russian",     native: "Ð ÑƒÑÑÐºÐ¸Ð¹" },
  { code: "sk", name: "Slovak",      native: "SlovenÄina" },
  { code: "sl", name: "Slovenian",   native: "SlovenÅ¡Äina" },
  { code: "sv", name: "Swedish",     native: "Svenska" },
  { code: "sw", name: "Swahili",     native: "Kiswahili" },
  { code: "ta", name: "Tamil",       native: "à®¤à®®à®¿à®´à¯" },
  { code: "th", name: "Thai",        native: "à¹„à¸—à¸¢" },
  { code: "tr", name: "Turkish",     native: "TÃ¼rkÃ§e" },
  { code: "uk", name: "Ukrainian",   native: "Ð£ÐºÑ€Ð°Ñ—Ð½ÑÑŒÐºÐ°" },
  { code: "vi", name: "Vietnamese",  native: "Tiáº¿ng Viá»‡t" },
  { code: "zh", name: "Chinese",     native: "ä¸­æ–‡" },
];

const MORSE_MAP = {
  A:".-",B:"-...",C:"-.-.",D:"-..",E:".",F:"..-.",G:"--.",H:"....",I:"..",J:".---",
  K:"-.-",L:".-..",M:"--",N:"-.",O:"---",P:".--.",Q:"--.-",R:".-.",S:"...",T:"-",
  U:"..-",V:"...-",W:".--",X:"-..-",Y:"-.--",Z:"--..",
  "1":".----","2":"..---","3":"...--","4":"....-","5":".....",
  "6":"-....","7":"--...","8":"---..","9":"----.","0":"-----"
};

const NATO_MAP = {
  A:"Alfa",B:"Bravo",C:"Charlie",D:"Delta",E:"Echo",F:"Foxtrot",G:"Golf",H:"Hotel",
  I:"India",J:"Juliet",K:"Kilo",L:"Lima",M:"Mike",N:"November",O:"Oscar",P:"Papa",
  Q:"Quebec",R:"Romeo",S:"Sierra",T:"Tango",U:"Uniform",V:"Victor",W:"Whiskey",
  X:"X-ray",Y:"Yankee",Z:"Zulu"
};

const BRAILLE_MAP = "â â ƒâ ‰â ™â ‘â ‹â ›â “â Šâ šâ …â ‡â â â •â â Ÿâ —â Žâ žâ ¥â §â ºâ ­â ½â µ";
const DATAMUSE_API = "https://api.datamuse.com/words";

const FUN_ENCODINGS = [
  {
    name: "Pig Latin", native: "Igpay Atinlay", isFun: true,
    encode(text) {
      return text.replace(/[a-z]+/gi, word => {
        const lower = word.toLowerCase();
        const cap = word[0] === word[0].toUpperCase();
        let result;
        if (/^[aeiou]/.test(lower)) {
          result = lower + "way";
        } else {
          const m = lower.match(/^([^aeiou]+)(.*)/);
          result = m ? m[2] + m[1] + "ay" : lower + "ay";
        }
        return cap ? result[0].toUpperCase() + result.slice(1) : result;
      });
    }
  },
  {
    name: "Morse Code", native: "-- --- Â·-Â· Â·Â·Â· Â·", isFun: true,
    encode(text) {
      return text.toUpperCase().split("").map(c =>
        MORSE_MAP[c] || (c === " " ? "/" : c)
      ).join(" ");
    }
  },
  {
    name: "NATO Phonetic", native: "Alfa Bravo Charlie", isFun: true,
    encode(text) {
      return text.toUpperCase().split("").map(c =>
        NATO_MAP[c] || (c === " " ? " / " : c)
      ).join(" ");
    }
  },
  {
    name: "Braille", native: "â ƒâ —â â Šâ ‡â ‡â ‘", isFun: true,
    encode(text) {
      return [...text.toLowerCase()].map(c => {
        const i = c.charCodeAt(0) - 97;
        return (i >= 0 && i < 26) ? BRAILLE_MAP[i] : c;
      }).join("");
    }
  },
  {
    name: "Leet Speak", native: "1337", isFun: true,
    encode(text) {
      const map = {a:"4",e:"3",i:"1",o:"0",s:"5",t:"7",l:"1",g:"9"};
      return [...text].map(c => map[c.toLowerCase()] || c).join("");
    }
  },
  {
    name: "Backwards", native: "sdrawkcaB", isFun: true,
    encode(text) {
      return text.split(/(\s+)/).map(part =>
        /^\s+$/.test(part) ? part : [...part].reverse().join("")
      ).join("");
    }
  },
  {
    name: "ROT13", native: "EBG13", isFun: true,
    encode(text) {
      return text.replace(/[a-z]/gi, c => {
        const base = c <= "Z" ? 65 : 97;
        return String.fromCharCode(((c.charCodeAt(0) - base + 13) % 26) + base);
      });
    }
  },
  {
    name: "School Paper", native: "Thesaurus Mode", isFun: true,
    encode(text) {
      return text;
    },
    async encodeAsync(text) {
      const words = [...text.matchAll(/\b[A-Za-z]{4,}\b/g)];
      if (!words.length) return text;

      const targetCount = Math.max(1, Math.floor(words.length * 0.5));
      const selected = [...words]
        .sort((a, b) => (b[0].length - a[0].length) || (Math.random() - 0.5))
        .slice(0, targetCount);

      const replacements = await Promise.all(selected.map(async (m) => {
        const original = m[0];
        const lower = original.toLowerCase();
        try {
          const resp = await fetch(`${DATAMUSE_API}?rel_syn=${encodeURIComponent(lower)}&max=15`);
          if (!resp.ok) return null;
          const data = await resp.json();
          const options = data
            .map(d => d.word)
            .filter(w => /^[A-Za-z][A-Za-z'-]*$/.test(w))
            .filter(w => w.toLowerCase() !== lower);
          if (!options.length) return null;
          let picked = options[Math.floor(Math.random() * options.length)];
          if (original.toUpperCase() === original) picked = picked.toUpperCase();
          else if (original[0] === original[0].toUpperCase() && original.slice(1) === original.slice(1).toLowerCase()) {
            picked = picked[0].toUpperCase() + picked.slice(1).toLowerCase();
          }
          return { index: m.index, length: original.length, replacement: picked };
        } catch {
          return null;
        }
      }));

      let out = text;
      for (const r of replacements.filter(Boolean).sort((a, b) => b.index - a.index)) {
        out = out.slice(0, r.index) + r.replacement + out.slice(r.index + r.length);
      }
      return out;
    }
  },
  {
    name: "Ransom Note", native: "âœ‚ï¸ðŸ“°", isFun: true,
    _styles: [
      [0x1D400, 0x1D41A],  // Bold Serif
      [0x1D468, 0x1D482],  // Bold Italic
      [0x1D4D0, 0x1D4EA],  // Script Bold
      [0x1D56C, 0x1D586],  // Bold Fraktur
      [0x1D5D4, 0x1D5EE],  // Sans Bold
      [0x1D670, 0x1D68A],  // Monospace
      [0xFF21,  0xFF41],    // Fullwidth
      [0x24B6,  0x24D0],   // Circled
    ],
    _styledChar(c) {
      const code = c.codePointAt(0);
      const s = this._styles[Math.floor(Math.random() * this._styles.length)];
      if (code >= 65 && code <= 90)  return String.fromCodePoint(s[0] + code - 65);
      if (code >= 97 && code <= 122) return String.fromCodePoint(s[1] + code - 97);
      return c;
    },
    encode(text) {
      return [...text].map(c => this._styledChar(c)).join("");
    },
    encodeHtml(text) {
      const sizes = [0.7, 0.85, 1, 1.2, 1.4, 1.65];
      return text.split(/(\s+)/).map(part => {
        if (/^\s+$/.test(part)) return " ";
        const size = sizes[Math.floor(Math.random() * sizes.length)];
        const rot = (Math.random() * 10 - 5).toFixed(1);
        const letters = [...part].map(c => {
          const code = c.codePointAt(0);
          if ((code >= 65 && code <= 90) || (code >= 97 && code <= 122)) return this._styledChar(c);
          return c.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }).join("");
        return `<span style="display:inline-block;font-size:${size}em;transform:rotate(${rot}deg);vertical-align:middle;margin:0 0.05em">${letters}</span>`;
      }).join("");
    }
  },
  {
    name: "GeoCities", native: "ðŸš§ Under Construction", isFun: true,
    _colors: ["lime","red","blue","magenta","cyan","yellow","hotpink","purple","orange","maroon","navy","green","deeppink","aqua"],
    _faces: ["Comic Sans MS","Papyrus","Times New Roman","Courier New","Impact","Arial Black"],
    _sizes: ["2","3","4","5","6","7"],
    _marquees: ["scroll","alternate","slide"],
    encode(text) {
      const c = this._colors[Math.floor(Math.random() * this._colors.length)];
      const f = this._faces[Math.floor(Math.random() * this._faces.length)];
      return `<marquee><font color="${c}" face="${f}"><b><blink>${text}</blink></b></font></marquee>`;
    },
    encodeHtml(text) {
      const words = text.split(/(\s+)/);
      let html = words.map(part => {
        if (/^\s+$/.test(part)) return " ";
        const safe = escapeHtml(part);
        const color = this._colors[Math.floor(Math.random() * this._colors.length)];
        const face = this._faces[Math.floor(Math.random() * this._faces.length)];
        const size = this._sizes[Math.floor(Math.random() * this._sizes.length)];
        let inner = safe;
        if (Math.random() < 0.4) inner = `<b>${inner}</b>`;
        if (Math.random() < 0.3) inner = `<i>${inner}</i>`;
        if (Math.random() < 0.3) inner = `<u>${inner}</u>`;
        if (Math.random() < 0.2) inner = `<s>${inner}</s>`;
        if (Math.random() < 0.25) inner = `<blink>${inner}</blink>`;
        if (Math.random() < 0.15) inner = `<sub>${inner}</sub>`;
        else if (Math.random() < 0.15) inner = `<sup>${inner}</sup>`;
        return `<font color="${color}" face="${face}" size="${size}">${inner}</font>`;
      }).join("");
      if (Math.random() < 0.4) {
        const behavior = this._marquees[Math.floor(Math.random() * this._marquees.length)];
        const dir = Math.random() < 0.5 ? "left" : "right";
        html = `<marquee behavior="${behavior}" direction="${dir}" scrollamount="${2 + Math.floor(Math.random() * 4)}">${html}</marquee>`;
      }
      return html;
    }
  },
  {
    name: "Spongebob", native: "sPoNgEbOb", isFun: true,
    encode(text) {
      let upper = false;
      return [...text].map(c => {
        if (/[a-z]/i.test(c)) { upper = !upper; return upper ? c.toUpperCase() : c.toLowerCase(); }
        return c;
      }).join("");
    }
  },
  {
    name: "Upside Down", native: "uÊop Çpá´‰sdâˆ©", isFun: true,
    _map: {a:"É",b:"q",c:"É”",d:"p",e:"Ç",f:"ÉŸ",g:"Æƒ",h:"É¥",i:"á´‰",j:"É¾",k:"Êž",l:"l",m:"É¯",n:"u",o:"o",p:"d",q:"b",r:"É¹",s:"s",t:"Ê‡",u:"n",v:"ÊŒ",w:"Ê",x:"x",y:"ÊŽ",z:"z",A:"âˆ€",B:"ê“­",C:"Æ†",D:"ê“·",E:"ÆŽ",F:"â„²",G:"â…",H:"H",I:"I",J:"Å¿",K:"ê“˜",L:"Ë¥",M:"W",N:"N",O:"O",P:"Ô€",Q:"ê¹",R:"ê“¤",S:"S",T:"âŠ¥",U:"âˆ©",V:"Î›",W:"M",X:"X",Y:"â…„",Z:"Z","1":"Æ–","2":"á„…","3":"Æ","4":"ã„£","5":"Ï›","6":"9","7":"â±¢","8":"8","9":"6","0":"0",".":"Ë™",",":"'","?":"Â¿","!":"Â¡","'":",",'(':')',')':'('},
    encode(text) {
      return [...text].map(c => this._map[c] || c).reverse().join("");
    }
  },
  {
    name: "Scrabble", native: "Triple Word Score", isFun: true,
    _pts: {A:1,B:3,C:3,D:2,E:1,F:4,G:2,H:4,I:1,J:8,K:5,L:1,M:3,N:1,O:1,P:3,Q:10,R:1,S:1,T:1,U:1,V:4,W:4,X:8,Y:4,Z:10},
    _buildGrid(text) {
      const words = text.toUpperCase().split(/\s+/)
        .map(w => w.replace(/[^A-Z]/g, ""))
        .filter(w => w.length >= 2)
        .slice(0, 8);
      if (!words.length) return null;

      const grid = {};
      const set = (x, y, ch) => { grid[`${x},${y}`] = ch; };
      const get = (x, y) => grid[`${x},${y}`];

      for (let i = 0; i < words[0].length; i++) set(i, 0, words[0][i]);
      let nextDir = "v";

      for (let w = 1; w < words.length; w++) {
        const word = words[w];
        let placed = false;

        for (const tryDir of [nextDir, nextDir === "v" ? "h" : "v"]) {
          if (placed) break;
          for (let wi = 0; wi < word.length && !placed; wi++) {
            for (const [key, letter] of Object.entries(grid)) {
              if (letter !== word[wi]) continue;
              const [gx, gy] = key.split(",").map(Number);

              let ok = true;
              const cells = [];
              for (let i = 0; i < word.length; i++) {
                const nx = tryDir === "h" ? gx - wi + i : gx;
                const ny = tryDir === "v" ? gy - wi + i : gy;
                const existing = get(nx, ny);
                if (existing && existing !== word[i]) { ok = false; break; }
                if (!existing) cells.push({ x: nx, y: ny, letter: word[i] });
              }

              if (ok && cells.length > 0) {
                for (const c of cells) set(c.x, c.y, c.letter);
                placed = true;
                break;
              }
            }
          }
        }
        if (placed) nextDir = nextDir === "v" ? "h" : "v";
      }

      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      for (const key of Object.keys(grid)) {
        const [x, y] = key.split(",").map(Number);
        if (x < minX) minX = x; if (x > maxX) maxX = x;
        if (y < minY) minY = y; if (y > maxY) maxY = y;
      }
      return { grid, get, minX, maxX, minY, maxY };
    },
    encode(text) {
      const b = this._buildGrid(text);
      if (!b) return text;
      let out = "";
      for (let y = b.minY; y <= b.maxY; y++) {
        let row = "";
        for (let x = b.minX; x <= b.maxX; x++) {
          const ch = b.get(x, y);
          row += ch ? ch + " " : "  ";
        }
        out += row.trimEnd() + "\n";
      }
      return out.trimEnd();
    },
    encodeHtml(text) {
      const b = this._buildGrid(text);
      if (!b) return escapeHtml(text);
      const cols = b.maxX - b.minX + 1;
      const sz = "clamp(1.4rem, 5vw, 2rem)";
      let html = `<div style="display:inline-grid;grid-template-columns:repeat(${cols},${sz});gap:2px;padding:6px;background:#1a6b3c;border-radius:6px;font-family:serif;font-weight:700;">`;
      for (let y = b.minY; y <= b.maxY; y++) {
        for (let x = b.minX; x <= b.maxX; x++) {
          const ch = b.get(x, y);
          if (ch) {
            const p = this._pts[ch] || 0;
            html += `<div style="width:${sz};height:${sz};background:linear-gradient(135deg,#FAEBD7,#F5DEB3);border:1px solid #C4A35A;border-radius:3px;display:flex;align-items:center;justify-content:center;position:relative;font-size:calc(${sz} * 0.55);box-shadow:1px 1px 2px rgba(0,0,0,0.2);color:#1e1e2f;">${ch}<span style="position:absolute;bottom:1px;right:2px;font-size:calc(${sz} * 0.28);font-weight:400;">${p}</span></div>`;
          } else {
            html += `<div style="width:${sz};height:${sz};background:#166434;border-radius:2px;"></div>`;
          }
        }
      }
      html += "</div>";
      return html;
    }
  },
  {
    name: "Maligned Fonts", native: "Comic Papyrus", isFun: true,
    _fonts: [
      "Comic Sans MS, cursive",
      "Papyrus, fantasy",
      "Impact, sans-serif",
      "Brush Script MT, cursive",
      "Courier New, monospace",
      "Arial Black, sans-serif",
      "Trebuchet MS, sans-serif",
      "Luminari, fantasy",
      "Copperplate, fantasy",
      "Jokerman, fantasy",
    ],
    encode(text) {
      return text.split(/(\s+)/).map(part => {
        if (/^\s+$/.test(part)) return " ";
        const font = this._fonts[Math.floor(Math.random() * this._fonts.length)].split(",")[0];
        return `${part} [${font}]`;
      }).join("");
    },
    encodeHtml(text) {
      const sizes = [0.85, 1, 1.15, 1.35, 1.55];
      return text.split(/(\s+)/).map(part => {
        if (/^\s+$/.test(part)) return " ";
        const font = this._fonts[Math.floor(Math.random() * this._fonts.length)];
        const size = sizes[Math.floor(Math.random() * sizes.length)];
        return `<span style="font-family:${font};font-size:${size}em;vertical-align:middle;">${escapeHtml(part)}</span>`;
      }).join(" ");
    }
  },
];

const phraseEl    = document.getElementById("phrase");
const startLangEl = document.getElementById("startLang");
const stepsEl     = document.getElementById("steps");
const stepsValEl  = document.getElementById("stepsVal");
const goBtn       = document.getElementById("goBtn");
const goBtnText   = document.getElementById("goBtnText");
const chainEl     = document.getElementById("chain");
const resultEl    = document.getElementById("result");
const errorEl     = document.getElementById("error");
const resetBtn    = document.getElementById("resetBtn");
const comboCountEl = document.getElementById("comboCount");

LANGUAGES.forEach(lang => {
  const opt = document.createElement("option");
  opt.value = lang.code;
  opt.textContent = `${lang.name} (${lang.native})`;
  startLangEl.appendChild(opt);
});

const browserLang = (navigator.language || "en").split("-")[0].toLowerCase();
const hasMatch = LANGUAGES.some(l => l.code === browserLang);
startLangEl.value = hasMatch ? browserLang : "en";

const emailRow     = document.getElementById("emailRow");
const emailInput   = document.getElementById("emailInput");
const emailSaveBtn = document.getElementById("emailSaveBtn");

let apiEmail = localStorage.getItem("tt_email") || "";
if (apiEmail) emailInput.value = apiEmail;

emailSaveBtn.addEventListener("click", () => {
  apiEmail = emailInput.value.trim();
  if (apiEmail) {
    localStorage.setItem("tt_email", apiEmail);
    emailRow.style.display = "none";
  }
});

let running = false;
let abortCtrl = null;
let chainLog = [];
let carouselTimer = null;
let carouselIndex = 0;
let carouselItems = [];
let chainCollapsedRefs = null;

function stopCarousel() {
  if (carouselTimer) clearInterval(carouselTimer);
  carouselTimer = null;
  carouselIndex = 0;
  carouselItems = [];
}

function permutationCount(x, n) {
  if (n < 0) return 0n;
  if (n === 0) return 1n;
  if (n > x) return 0n;
  let out = 1n;
  for (let i = 0; i < n; i++) out *= BigInt(x - i);
  return out;
}

function powerCount(x, n) {
  if (n < 0) return 0n;
  let out = 1n;
  for (let i = 0; i < n; i++) out *= BigInt(x);
  return out;
}

function formatBigCount(v) {
  const s = v.toString();
  if (s.length <= 3) return s;
  if (s.length <= 12) return s.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  return `${s.slice(0, 3)}.${s.slice(3, 6)}e+${s.length - 1}`;
}

function updateComboCount() {
  if (!comboCountEl) return;
  const n = parseInt(stepsEl.value, 10);
  const xLang = LANGUAGES.length - 1 + (startLangEl.value === "en" ? FUN_ENCODINGS.length : 0);
  const xEnc = FUN_ENCODINGS.length;

  let count;
  let model;
  if (encodingsOnlyMode) {
    count = powerCount(xEnc, n);
    model = `${xEnc}^${n}`;
  } else {
    count = permutationCount(xLang, n);
    model = `${xLang}P${n}`;
  }

  comboCountEl.textContent = `Possible paths: ${formatBigCount(count)} (${model})`;
}

function collapseChainToCarousel(items) {
  const stepEls = [...chainEl.querySelectorAll(".step")];
  if (stepEls.length < 3 || !items.length) return false;
  const first = stepEls[0];
  const last = stepEls[stepEls.length - 1];
  const hidden = [];

  for (const child of [...chainEl.children]) {
    if (child === first || child === last) continue;
    hidden.push(child);
    child.style.display = "none";
  }

  const connTop = document.createElement("div");
  connTop.className = "connector";
  connTop.textContent = "â†“";
  const wrap = document.createElement("div");
  wrap.className = "carousel-wrap";
  const connBottom = document.createElement("div");
  connBottom.className = "connector";
  connBottom.textContent = "â†“";

  chainEl.insertBefore(connTop, last);
  chainEl.insertBefore(wrap, last);
  chainEl.insertBefore(connBottom, last);

  chainCollapsedRefs = { hidden, connTop, wrap, connBottom };
  startCarousel(wrap, items);
  return true;
}

function expandChainFromCarousel() {
  stopCarousel();
  if (!chainCollapsedRefs) return;
  const { hidden, connTop, wrap, connBottom } = chainCollapsedRefs;
  wrap.style.minHeight = "";
  connTop.remove();
  wrap.remove();
  connBottom.remove();
  for (const node of hidden) node.style.display = "";
  chainCollapsedRefs = null;
}

function renderCarouselStep(container) {
  if (!carouselItems.length) {
    container.innerHTML = "";
    return;
  }
  const item = carouselItems[carouselIndex];
  container.innerHTML = getCarouselStepHtml(item, carouselIndex, carouselItems.length);
}

function getCarouselStepHtml(item, index, total) {
  return `
    <div class="step" style="opacity:1;transform:none;animation:none;">
      <div class="step-header">
        <span class="lang-label">${escapeHtml(item.lang)}</span>
      </div>
      <div class="step-text">${escapeHtml(item.text)}</div>
      <div class="carousel-meta">${index + 1} / ${total}</div>
    </div>
  `;
}

function getMaxCarouselHeight(container, items) {
  if (!items.length) return 0;
  const probe = document.createElement("div");
  probe.style.position = "absolute";
  probe.style.visibility = "hidden";
  probe.style.pointerEvents = "none";
  probe.style.left = "-99999px";
  probe.style.top = "0";
  probe.style.width = `${container.clientWidth || chainEl.clientWidth || 320}px`;
  document.body.appendChild(probe);

  let max = 0;
  for (let i = 0; i < items.length; i++) {
    probe.innerHTML = getCarouselStepHtml(items[i], i, items.length);
    max = Math.max(max, probe.offsetHeight);
  }
  probe.remove();
  return max;
}

function startCarousel(container, items) {
  stopCarousel();
  carouselItems = items;
  const maxHeight = getMaxCarouselHeight(container, carouselItems);
  container.style.minHeight = maxHeight ? `${maxHeight}px` : "";
  renderCarouselStep(container);
  if (carouselItems.length <= 1) return;
  carouselTimer = setInterval(() => {
    carouselIndex = (carouselIndex + 1) % carouselItems.length;
    renderCarouselStep(container);
  }, 2200);
}

stepsEl.addEventListener("input", () => { stepsValEl.textContent = stepsEl.value; updateComboCount(); });
startLangEl.addEventListener("change", updateComboCount);

goBtn.addEventListener("click", () => {
  if (running) { abortCtrl?.abort(); stopMorsePlayback(); return; }
  startChain();
});

resetBtn.addEventListener("click", () => {
  if (running) { abortCtrl?.abort(); }
  stopMorsePlayback();
  expandChainFromCarousel();
  chainEl.style.display = "";
  chainEl.innerHTML = "";
  resultEl.innerHTML = "";
  errorEl.innerHTML = "";
  resetBtn.style.display = "none";
  phraseEl.value = "";
  phraseEl.focus();
  phraseEl.scrollIntoView({ behavior: "smooth", block: "center" });
});

function pickRandomSteps(count, excludeCode, encodingsOnlyMode) {
  const steps = [];

  if (encodingsOnlyMode) {
    const schoolPaper = FUN_ENCODINGS.find(e => e.name === "School Paper");
    const basePool = [...FUN_ENCODINGS];
    if (schoolPaper && count > 0) {
      steps.push(schoolPaper);
      const idx = basePool.findIndex(e => e.name === "School Paper");
      if (idx >= 0) basePool.splice(idx, 1);
    }

    let pool = [...basePool];
    while (steps.length < count) {
      if (!pool.length) pool = [...basePool];
      const idx = Math.floor(Math.random() * pool.length);
      steps.push(pool.splice(idx, 1)[0]);
    }
    return steps.sort(() => Math.random() - 0.5);
  }

  if (excludeCode === "en") {
    const minFun = Math.min(2, count, FUN_ENCODINGS.length);
    const maxFun = Math.max(minFun, Math.floor(count / 4));
    const funCount = minFun + Math.floor(Math.random() * (maxFun - minFun + 1));
    const funPool = [...FUN_ENCODINGS];
    for (let i = 0; i < funCount && funPool.length; i++) {
      const idx = Math.floor(Math.random() * funPool.length);
      steps.push(funPool.splice(idx, 1)[0]);
    }
  }

  const langPool = LANGUAGES.filter(l => l.code !== excludeCode);
  const remaining = count - steps.length;
  for (let i = 0; i < remaining && langPool.length; i++) {
    const idx = Math.floor(Math.random() * langPool.length);
    steps.push(langPool.splice(idx, 1)[0]);
  }

  return steps;
}

class RateLimitError extends Error {
  constructor() { super("Rate limited"); this.name = "RateLimitError"; }
}

async function translate(text, from, to, signal) {
  let url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${from}|${to}`;
  if (apiEmail) url += `&de=${encodeURIComponent(apiEmail)}`;
  const resp = await fetch(url, { signal });
  if (resp.status === 429) { showEmailPrompt(); throw new RateLimitError(); }
  if (!resp.ok) throw new Error(`API returned ${resp.status}`);
  const data = await resp.json();
  if (data.responseStatus === 429 || data.responseStatus === "429") { showEmailPrompt(); throw new RateLimitError(); }
  if (data.responseStatus !== 200 && data.responseStatus !== "200") {
    throw new Error(data.responseDetails || "Translation failed");
  }
  return data.responseData.translatedText;
}

function showEmailPrompt() {
  if (!apiEmail) emailRow.style.display = "";
}

async function encodeFunStep(step, text) {
  if (typeof step.encodeAsync === "function") return step.encodeAsync(text);
  return step.encode(text);
}

let voicesReady = false;
let cachedVoices = [];

function loadVoices() {
  cachedVoices = speechSynthesis.getVoices();
  if (cachedVoices.length) voicesReady = true;
}

function waitForVoices() {
  if (voicesReady) return Promise.resolve();
  return new Promise(resolve => {
    loadVoices();
    if (voicesReady) return resolve();
    const onchange = () => { loadVoices(); resolve(); };
    speechSynthesis.addEventListener("voiceschanged", onchange, { once: true });
    setTimeout(() => { loadVoices(); resolve(); }, 2000);
  });
}

function hasVoiceForLang(langCode) {
  return cachedVoices.some(v => v.lang === langCode || v.lang.startsWith(langCode + "-"));
}

let morseAudioCtx = null;
let activeMorseOsc = [];

function stopMorsePlayback() {
  speechSynthesis.cancel();
  for (const osc of activeMorseOsc) {
    try { osc.stop(); } catch { /* already ended */ }
    try { osc.disconnect(); } catch { /* already disconnected */ }
  }
  activeMorseOsc = [];
}

async function playMorse(text) {
  stopMorsePlayback();
  if (!text) return;
  if (!morseAudioCtx) {
    morseAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (morseAudioCtx.state === "suspended") {
    await morseAudioCtx.resume();
  }

  const unit = 90;
  let offsetMs = 0;
  const tokens = text.trim().split(/\s+/);

  for (let t = 0; t < tokens.length; t++) {
    const token = tokens[t];
    if (token === "/") {
      offsetMs += 7 * unit;
      continue;
    }

    for (let i = 0; i < token.length; i++) {
      const sym = token[i];
      const durMs = sym === "." ? unit : sym === "-" ? 3 * unit : 0;
      if (!durMs) continue;

      const osc = morseAudioCtx.createOscillator();
      const gain = morseAudioCtx.createGain();
      osc.type = "sine";
      osc.frequency.value = 680;
      gain.gain.setValueAtTime(0.0001, morseAudioCtx.currentTime + offsetMs / 1000);
      gain.gain.exponentialRampToValueAtTime(0.18, morseAudioCtx.currentTime + (offsetMs + 10) / 1000);
      gain.gain.exponentialRampToValueAtTime(0.0001, morseAudioCtx.currentTime + (offsetMs + durMs) / 1000);
      osc.connect(gain);
      gain.connect(morseAudioCtx.destination);
      osc.onended = () => {
        try { osc.disconnect(); } catch { /* ignore */ }
        const idx = activeMorseOsc.indexOf(osc);
        if (idx >= 0) activeMorseOsc.splice(idx, 1);
      };
      osc.start(morseAudioCtx.currentTime + offsetMs / 1000);
      osc.stop(morseAudioCtx.currentTime + (offsetMs + durMs + 20) / 1000);
      activeMorseOsc.push(osc);

      offsetMs += durMs;
      if (i < token.length - 1) offsetMs += unit;
    }

    if (t < tokens.length - 1) offsetMs += 3 * unit;
  }
}

function speak(text, langCode) {
  stopMorsePlayback();
  const utter = new SpeechSynthesisUtterance(text);
  utter.lang = langCode;
  const match = cachedVoices.find(v => v.lang.startsWith(langCode));
  if (match) utter.voice = match;
  speechSynthesis.speak(utter);
}

function addStepCard(langName, langNative, langCode, text, index, htmlContent, speakHandler) {
  if (chainEl.children.length > 0) {
    const conn = document.createElement("div");
    conn.className = "connector";
    conn.textContent = "â†“";
    chainEl.appendChild(conn);
  }

  const card = document.createElement("div");
  card.className = "step";
  card.style.animationDelay = `${index * 0.05}s`;

  const canSpeak = !!speakHandler || hasVoiceForLang(langCode);
  card.innerHTML = `
    <div class="step-header">
      <span class="lang-label">${langName}<span class="lang-native">${langNative}</span></span>
      <button class="speak-btn" title="Listen" ${canSpeak ? "" : "disabled"}>&#x1f50a;</button>
    </div>
    <div class="step-text">${htmlContent || escapeHtml(text)}</div>
  `;

  card.querySelector(".speak-btn").addEventListener("click", () => {
    if (speakHandler) return speakHandler();
    speak(text, langCode);
  });
  chainEl.appendChild(card);
}

function showResult(original, final) {
  const diff = Diff.diffWords(original.toLowerCase(), final.toLowerCase());

  let html = "";
  let same = 0, total = 0;
  for (const part of diff) {
    const words = part.value.trim().split(/\s+/).filter(Boolean).length;
    total += words;
    if (!part.added && !part.removed) {
      same += words;
      html += escapeHtml(part.value);
    } else if (part.removed) {
      html += `<span class="removed">${escapeHtml(part.value)}</span>`;
    } else {
      html += `<span class="added">${escapeHtml(part.value)}</span>`;
    }
  }

  const pct = total > 0 ? Math.round((same / total) * 100) : 0;

  const conn = document.createElement("div");
  conn.className = "connector";
  conn.textContent = "â†“";
  chainEl.appendChild(conn);

  const steps = chainLog.map(s => `${s.lang}: ${s.text}`).join("\n\n");
  const shareUrl = buildShareUrl(original, chainLog.length, startLangEl.value);
  const summaryText = `${toBold(original)}\n\n${steps}\n\n${toBold(final)}\n\n${pct}% similarity\n\nTry it: ${shareUrl}`;
  const hasIntermediates = chainLog.length > 0;

  resultEl.innerHTML = `
    <div class="result-card">
      <h2>Final vs. Original</h2>
      <div class="diff-display">${html}</div>
      <span class="similarity">${pct}%</span>
      <span class="similarity-label">word similarity</span>
      <div class="result-actions">
        <button class="copy-btn" id="copyBtn">&#x1f4cb; Copy for texting</button>
        ${hasIntermediates ? '<button class="copy-btn" id="toggleCarouselBtn">&#x1f5d2; Collapse to carousel</button>' : ""}
      </div>
      <div id="carouselWrap" class="carousel-wrap" style="display:none"></div>
    </div>
  `;

  document.getElementById("copyBtn").addEventListener("click", async (e) => {
    try {
      await navigator.clipboard.writeText(summaryText);
      const btn = e.currentTarget;
      btn.classList.add("copied");
      btn.innerHTML = "&#x2705; Copied!";
      setTimeout(() => { btn.classList.remove("copied"); btn.innerHTML = "&#x1f4cb; Copy for texting"; }, 2000);
    } catch { /* clipboard not available */ }
  });

  const toggleBtn = document.getElementById("toggleCarouselBtn");
  const carouselWrap = document.getElementById("carouselWrap");
  if (toggleBtn && carouselWrap) {
    let collapsed = false;
    toggleBtn.addEventListener("click", () => {
      collapsed = !collapsed;
      if (collapsed) {
        const ok = collapseChainToCarousel([...chainLog]);
        if (!ok) {
          collapsed = false;
          return;
        }
        carouselWrap.style.display = "none";
        toggleBtn.innerHTML = "&#x2195; Expand intermediate steps";
      } else {
        expandChainFromCarousel();
        carouselWrap.style.display = "none";
        toggleBtn.innerHTML = "&#x1f5d2; Collapse to carousel";
      }
    });
  }
}

function buildShareUrl(phrase, steps, lang) {
  const url = new URL(window.location.href.split("?")[0]);
  url.searchParams.set("phrase", phrase);
  url.searchParams.set("steps", steps);
  if (lang !== "en") url.searchParams.set("lang", lang);
  return url.toString();
}

function sanitizeInput(raw) {
  if (typeof raw !== "string") return "";
  const stripped = raw.replace(/<[^>]*>/g, "").trim();
  return stripped.slice(0, 500);
}

function toBold(str) {
  return [...str].map(c => {
    const code = c.codePointAt(0);
    if (code >= 65 && code <= 90)  return String.fromCodePoint(code - 65 + 0x1D5D4);  // bold sans A-Z
    if (code >= 97 && code <= 122) return String.fromCodePoint(code - 97 + 0x1D5EE);  // bold sans a-z
    if (code >= 48 && code <= 57)  return String.fromCodePoint(code - 48 + 0x1D7EC);  // bold sans 0-9
    return c;
  }).join("");
}

function escapeHtml(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
}

function setRunning(state) {
  running = state;
  phraseEl.disabled = state;
  stepsEl.disabled = state;
  startLangEl.disabled = state;
  goBtnText.textContent = state ? "Stop" : "Start";
}

function delay(ms, signal) {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(resolve, ms);
    signal?.addEventListener("abort", () => { clearTimeout(timer); reject(new DOMException("Aborted", "AbortError")); });
  });
}

async function startChain() {
  const original = phraseEl.value.trim();
  if (!original) { phraseEl.focus(); return; }

  expandChainFromCarousel();
  chainEl.style.display = "";
  chainEl.innerHTML = "";
  resultEl.innerHTML = "";
  errorEl.innerHTML = "";

  abortCtrl = new AbortController();
  setRunning(true);
  resetBtn.style.display = "";

  await waitForVoices();

  const startCode = startLangEl.value;
  const startLang = LANGUAGES.find(l => l.code === startCode);
  const startName = startLang ? startLang.name : "English";
  const startNative = startLang ? startLang.native : "English";

  const count = parseInt(stepsEl.value, 10);
  const steps = pickRandomSteps(count, startCode, encodingsOnlyMode);

  try {
    chainLog = [];
    addStepCard(startName, startNative + " Â· Start", startCode, original, 0);

    let current = original;
    let fromCode = startCode;
    let rateLimited = false;
    let stepIndex = 0;

    for (let i = 0; i < steps.length; i++) {
      const step = steps[i];
      await delay(350, abortCtrl.signal);

      if (step.isFun) {
        const isSchoolPaper = step.name === "School Paper";
        const funInput = isSchoolPaper ? current : original;
        const encoded = await encodeFunStep(step, funInput);
        if (isSchoolPaper) current = encoded;
        const html = step.encodeHtml ? step.encodeHtml(funInput) : null;
        const speakHandler = step.name === "Morse Code" ? () => playMorse(encoded) : null;
        addStepCard(step.name, step.native, "", encoded, i + 1, html, speakHandler);
        chainLog.push({ lang: step.name, text: encoded });
        incrementCounter();
      } else {
        try {
          current = await translate(current, fromCode, step.code, abortCtrl.signal);
        } catch (e) {
          if (e instanceof RateLimitError) { rateLimited = true; break; }
          throw e;
        }
        addStepCard(step.name, step.native, step.code, current, i + 1);
        chainLog.push({ lang: step.name, text: current });
        fromCode = step.code;
        incrementCounter();
      }
      stepIndex = i + 1;
    }

    if (rateLimited) {
      const usedNames = new Set(chainLog.map(s => s.lang));
      const unusedFun = FUN_ENCODINGS.filter(f => !usedNames.has(f.name));

      if (startCode === "en" && unusedFun.length) {
        errorEl.innerHTML = `<div class="error-msg">The translation API needs a breather! Filling in with some fun encodings instead.</div>`;
        for (const fun of unusedFun) {
          await delay(350, abortCtrl.signal);
          stepIndex++;
          const isSchoolPaper = fun.name === "School Paper";
          const funInput = isSchoolPaper ? current : original;
          const encoded = await encodeFunStep(fun, funInput);
          if (isSchoolPaper) current = encoded;
          const html = fun.encodeHtml ? fun.encodeHtml(funInput) : null;
          const speakHandler = fun.name === "Morse Code" ? () => playMorse(encoded) : null;
          addStepCard(fun.name, fun.native, "", encoded, stepIndex, html, speakHandler);
          chainLog.push({ lang: fun.name, text: encoded });
          incrementCounter();
        }
      } else {
        errorEl.innerHTML = `<div class="error-msg">The translation API needs a breather! Skipping ahead to the final step with what we have so far.</div>`;
      }
    }

    await delay(350, abortCtrl.signal);
    let finalText;
    if (encodingsOnlyMode) {
      finalText = current;
    } else {
      try {
        finalText = await translate(current, fromCode, startCode, abortCtrl.signal);
      } catch (e) {
        if (e instanceof RateLimitError) {
          if (fromCode === startCode) {
            finalText = current;
          } else {
            errorEl.innerHTML = `<div class="error-msg">The translation API needs a breather! Try again in a minute or use fewer steps.</div>`;
            return;
          }
        } else {
          throw e;
        }
      }
    }
    addStepCard(startName, startNative + " Â· Final", startCode, finalText, stepIndex + 1);
    incrementCounter();

    showResult(original, finalText);
  } catch (err) {
    if (err.name === "AbortError") {
      /* user cancelled */
    } else {
      errorEl.innerHTML = `<div class="error-msg">Something went wrong: ${escapeHtml(err.message)}</div>`;
    }
  } finally {
    setRunning(false);
  }
}

loadVoices();
speechSynthesis.addEventListener?.("voiceschanged", loadVoices);

const params = new URLSearchParams(window.location.search);
const initPhrase = sanitizeInput(params.get("phrase"));
if (initPhrase) {
  phraseEl.value = initPhrase;
}
const initSteps = parseInt(params.get("steps"), 10);
const minSteps = parseInt(stepsEl.min, 10);
const maxSteps = parseInt(stepsEl.max, 10);
if (initSteps >= minSteps && initSteps <= maxSteps) {
  stepsEl.value = initSteps;
  stepsValEl.textContent = initSteps;
}
const initLang = params.get("lang");
if (initLang && LANGUAGES.some(l => l.code === initLang)) {
  startLangEl.value = initLang;
}
const encodingsOnlyMode = params.get("xenc") === "1";
updateComboCount();

const COUNTER_URL = "https://api.counterapi.dev/v1/ChrisRWorkspace/telephone-translations";

function renderCounter(count) {
  const padded = String(count).padStart(6, "0");
  const digits = [...padded].map(d => `<span>${d}</span>`).join("");
  document.getElementById("visitorCounter").innerHTML =
    `<span class="counter-digits">${digits}</span> translations and counting`;
}

(async function loadCounter() {
  try {
    const resp = await fetch(COUNTER_URL);
    if (!resp.ok) return;
    const data = await resp.json();
    renderCounter(data.count ?? 0);
  } catch { /* counter unavailable */ }
})();

async function incrementCounter() {
  try {
    const resp = await fetch(`${COUNTER_URL}/up`);
    if (!resp.ok) return;
    const data = await resp.json();
    renderCounter(data.count ?? 0);
  } catch { /* counter unavailable */ }
}
</script>
</body>
</html>
