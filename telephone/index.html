<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Translation Telephone</title>
<script src="https://cdn.jsdelivr.net/npm/diff@7/dist/diff.min.js"></script>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #f4f1ee;
    --surface: #ffffff;
    --primary: #4361ee;
    --primary-hover: #3a56d4;
    --text: #1e1e2f;
    --text-muted: #6b7280;
    --border: #e2e0dc;
    --green: #16a34a;
    --green-bg: #dcfce7;
    --red: #dc2626;
    --red-bg: #fee2e2;
    --radius: 12px;
    --shadow: 0 2px 8px rgba(0,0,0,0.06);
  }

  body {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    padding: 2rem 1rem 4rem;
  }

  h1 {
    text-align: center;
    font-size: 2rem;
    font-weight: 700;
    margin-bottom: 0.25rem;
  }

  .subtitle {
    text-align: center;
    color: var(--text-muted);
    font-size: 0.95rem;
    margin-bottom: 2rem;
  }

  .container {
    max-width: 640px;
    margin: 0 auto;
  }

  /* Input area */
  .input-area {
    background: var(--surface);
    border-radius: var(--radius);
    padding: 1.5rem;
    box-shadow: var(--shadow);
    margin-bottom: 2rem;
  }

  .input-area label {
    display: block;
    font-weight: 600;
    margin-bottom: 0.4rem;
    font-size: 0.9rem;
  }

  .phrase-label-row {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    margin-bottom: 0.4rem;
  }

  .phrase-label-row label {
    margin-bottom: 0;
  }

  .phrase-label-row select {
    font-family: inherit;
    font-size: 0.9rem;
    font-weight: 600;
    padding: 0.2rem 0.4rem;
    border: 2px solid var(--border);
    border-radius: 6px;
    background: var(--surface);
    color: var(--primary);
    cursor: pointer;
    transition: border-color 0.2s;
  }

  .phrase-label-row select:focus {
    outline: none;
    border-color: var(--primary);
  }

  .input-area textarea {
    width: 100%;
    border: 2px solid var(--border);
    border-radius: 8px;
    padding: 0.75rem;
    font-size: 1rem;
    font-family: inherit;
    resize: vertical;
    min-height: 70px;
    transition: border-color 0.2s;
  }

  .input-area textarea:focus {
    outline: none;
    border-color: var(--primary);
  }

  .controls {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-top: 1rem;
    flex-wrap: wrap;
  }

  .slider-group {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex: 1;
    min-width: 200px;
  }

  .slider-group label {
    white-space: nowrap;
    margin-bottom: 0;
    font-size: 0.85rem;
  }

  .slider-group input[type="range"] {
    flex: 1;
    accent-color: var(--primary);
  }

  .slider-group .slider-val {
    font-weight: 700;
    font-size: 1.1rem;
    min-width: 1.5ch;
    text-align: center;
  }

  .btn {
    display: inline-flex;
    align-items: center;
    gap: 0.4rem;
    background: var(--primary);
    color: #fff;
    border: none;
    border-radius: 8px;
    padding: 0.65rem 1.4rem;
    font-size: 0.95rem;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s, opacity 0.2s;
    white-space: nowrap;
  }

  .btn:hover { background: var(--primary-hover); }
  .btn:disabled { opacity: 0.5; cursor: not-allowed; }

  .btn-reset {
    background: transparent;
    color: var(--text-muted);
    border: 2px solid var(--border);
  }
  .btn-reset:hover { background: var(--bg); color: var(--text); border-color: var(--text-muted); }

  /* Chain */
  .chain { display: flex; flex-direction: column; gap: 0; }

  .step {
    position: relative;
    background: var(--surface);
    border-radius: var(--radius);
    padding: 1rem 1.25rem;
    box-shadow: var(--shadow);
    opacity: 0;
    transform: translateY(12px);
    animation: fadeUp 0.4s forwards;
  }

  @keyframes fadeUp {
    to { opacity: 1; transform: translateY(0); }
  }

  .connector {
    display: flex;
    justify-content: center;
    padding: 0.15rem 0;
    color: var(--text-muted);
    font-size: 1.2rem;
    user-select: none;
  }

  .step-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 0.35rem;
  }

  .lang-label {
    font-weight: 700;
    font-size: 0.85rem;
    color: var(--primary);
    text-transform: uppercase;
    letter-spacing: 0.04em;
  }

  .lang-native {
    font-weight: 400;
    text-transform: none;
    color: var(--text-muted);
    letter-spacing: normal;
    margin-left: 0.4rem;
    font-size: 0.82rem;
  }

  .speak-btn {
    background: none;
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 0.25rem 0.5rem;
    cursor: pointer;
    font-size: 1rem;
    line-height: 1;
    transition: border-color 0.2s, background 0.2s;
  }

  .speak-btn:hover { border-color: var(--primary); background: #eef1ff; }
  .speak-btn:disabled { opacity: 0.35; cursor: not-allowed; }

  .step-text {
    font-size: 1.05rem;
    line-height: 1.5;
    word-break: break-word;
  }

  /* Result card */
  .result-card {
    background: var(--surface);
    border-radius: var(--radius);
    padding: 1.5rem;
    box-shadow: var(--shadow);
    opacity: 0;
    transform: translateY(12px);
    animation: fadeUp 0.4s forwards;
  }

  .result-card h2 {
    font-size: 1.1rem;
    margin-bottom: 0.75rem;
  }

  .diff-display {
    font-size: 1.1rem;
    line-height: 1.7;
    margin-bottom: 1rem;
    word-break: break-word;
  }

  .diff-display .added {
    background: var(--green-bg);
    color: var(--green);
    padding: 0.1em 0.2em;
    border-radius: 3px;
    font-weight: 600;
  }

  .diff-display .removed {
    background: var(--red-bg);
    color: var(--red);
    padding: 0.1em 0.2em;
    border-radius: 3px;
    text-decoration: line-through;
    font-weight: 600;
  }

  .similarity {
    display: inline-block;
    font-weight: 700;
    font-size: 1.5rem;
    margin-right: 0.5rem;
  }

  .similarity-label {
    color: var(--text-muted);
    font-size: 0.9rem;
  }

  .copy-btn {
    display: inline-flex;
    align-items: center;
    gap: 0.4rem;
    background: transparent;
    color: var(--text-muted);
    border: 2px solid var(--border);
    border-radius: 8px;
    padding: 0.5rem 1.1rem;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    margin-top: 1rem;
    transition: background 0.2s, color 0.2s, border-color 0.2s;
  }
  .copy-btn:hover { background: var(--bg); color: var(--text); border-color: var(--text-muted); }
  .copy-btn.copied {
    border-color: var(--green);
    color: var(--green);
    background: var(--green-bg);
  }

  .error-msg {
    background: var(--red-bg);
    color: var(--red);
    padding: 0.75rem 1rem;
    border-radius: 8px;
    font-size: 0.9rem;
    margin-top: 1rem;
  }

  blink {
    animation: oldblink 1s step-end infinite;
  }
  @keyframes oldblink {
    50% { opacity: 0; }
  }

  @media (max-width: 500px) {
    h1 { font-size: 1.5rem; }
    .controls { flex-direction: column; align-items: stretch; }
    .btn { justify-content: center; }
  }
</style>
</head>
<body>

<div class="container">
  <h1>Translation Telephone</h1>
  <p class="subtitle">Pass a phrase through random languages and see what happens.</p>

  <div class="input-area">
    <div class="phrase-label-row">
      <label for="phrase">Your phrase in</label>
      <select id="startLang"></select>
    </div>
    <textarea id="phrase" placeholder="e.g. The quick brown fox jumps over the lazy dog"></textarea>

    <div class="controls">
      <div class="slider-group">
        <label for="steps">Steps:</label>
        <input type="range" id="steps" min="2" max="25" value="8">
        <span class="slider-val" id="stepsVal">8</span>
      </div>
      <button class="btn" id="goBtn">
        <span id="goBtnText">Start</span>
      </button>
      <button class="btn btn-reset" id="resetBtn" style="display:none">Reset</button>
    </div>
  </div>

  <div id="chain" class="chain"></div>
  <div id="result"></div>
  <div id="error"></div>
</div>

<script>
const LANGUAGES = [
  { code: "en", name: "English",     native: "English" },
  { code: "ar", name: "Arabic",      native: "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©" },
  { code: "bg", name: "Bulgarian",   native: "Ð‘ÑŠÐ»Ð³Ð°Ñ€ÑÐºÐ¸" },
  { code: "bn", name: "Bengali",     native: "à¦¬à¦¾à¦‚à¦²à¦¾" },
  { code: "cs", name: "Czech",       native: "ÄŒeÅ¡tina" },
  { code: "da", name: "Danish",      native: "Dansk" },
  { code: "de", name: "German",      native: "Deutsch" },
  { code: "el", name: "Greek",       native: "Î•Î»Î»Î·Î½Î¹ÎºÎ¬" },
  { code: "es", name: "Spanish",     native: "EspaÃ±ol" },
  { code: "et", name: "Estonian",    native: "Eesti" },
  { code: "fa", name: "Persian",     native: "ÙØ§Ø±Ø³ÛŒ" },
  { code: "fi", name: "Finnish",     native: "Suomi" },
  { code: "fr", name: "French",      native: "FranÃ§ais" },
  { code: "ga", name: "Irish",       native: "Gaeilge" },
  { code: "he", name: "Hebrew",      native: "×¢×‘×¨×™×ª" },
  { code: "hi", name: "Hindi",       native: "à¤¹à¤¿à¤¨à¥à¤¦à¥€" },
  { code: "hr", name: "Croatian",    native: "Hrvatski" },
  { code: "hu", name: "Hungarian",   native: "Magyar" },
  { code: "id", name: "Indonesian",  native: "Bahasa Indonesia" },
  { code: "it", name: "Italian",     native: "Italiano" },
  { code: "ja", name: "Japanese",    native: "æ—¥æœ¬èªž" },
  { code: "ko", name: "Korean",      native: "í•œêµ­ì–´" },
  { code: "lt", name: "Lithuanian",  native: "LietuviÅ³" },
  { code: "lv", name: "Latvian",     native: "LatvieÅ¡u" },
  { code: "ms", name: "Malay",       native: "Bahasa Melayu" },
  { code: "nl", name: "Dutch",       native: "Nederlands" },
  { code: "no", name: "Norwegian",   native: "Norsk" },
  { code: "pl", name: "Polish",      native: "Polski" },
  { code: "pt", name: "Portuguese",  native: "PortuguÃªs" },
  { code: "ro", name: "Romanian",    native: "RomÃ¢nÄƒ" },
  { code: "ru", name: "Russian",     native: "Ð ÑƒÑÑÐºÐ¸Ð¹" },
  { code: "sk", name: "Slovak",      native: "SlovenÄina" },
  { code: "sl", name: "Slovenian",   native: "SlovenÅ¡Äina" },
  { code: "sv", name: "Swedish",     native: "Svenska" },
  { code: "sw", name: "Swahili",     native: "Kiswahili" },
  { code: "ta", name: "Tamil",       native: "à®¤à®®à®¿à®´à¯" },
  { code: "th", name: "Thai",        native: "à¹„à¸—à¸¢" },
  { code: "tr", name: "Turkish",     native: "TÃ¼rkÃ§e" },
  { code: "uk", name: "Ukrainian",   native: "Ð£ÐºÑ€Ð°Ñ—Ð½ÑÑŒÐºÐ°" },
  { code: "vi", name: "Vietnamese",  native: "Tiáº¿ng Viá»‡t" },
  { code: "zh", name: "Chinese",     native: "ä¸­æ–‡" },
];

const MORSE_MAP = {
  A:".-",B:"-...",C:"-.-.",D:"-..",E:".",F:"..-.",G:"--.",H:"....",I:"..",J:".---",
  K:"-.-",L:".-..",M:"--",N:"-.",O:"---",P:".--.",Q:"--.-",R:".-.",S:"...",T:"-",
  U:"..-",V:"...-",W:".--",X:"-..-",Y:"-.--",Z:"--..",
  "1":".----","2":"..---","3":"...--","4":"....-","5":".....",
  "6":"-....","7":"--...","8":"---..","9":"----.","0":"-----"
};

const NATO_MAP = {
  A:"Alfa",B:"Bravo",C:"Charlie",D:"Delta",E:"Echo",F:"Foxtrot",G:"Golf",H:"Hotel",
  I:"India",J:"Juliet",K:"Kilo",L:"Lima",M:"Mike",N:"November",O:"Oscar",P:"Papa",
  Q:"Quebec",R:"Romeo",S:"Sierra",T:"Tango",U:"Uniform",V:"Victor",W:"Whiskey",
  X:"X-ray",Y:"Yankee",Z:"Zulu"
};

const BRAILLE_MAP = "â â ƒâ ‰â ™â ‘â ‹â ›â “â Šâ šâ …â ‡â â â •â â Ÿâ —â Žâ žâ ¥â §â ºâ ­â ½â µ";

const FUN_ENCODINGS = [
  {
    name: "Pig Latin", native: "Igpay Atinlay", isFun: true,
    encode(text) {
      return text.replace(/[a-z]+/gi, word => {
        const lower = word.toLowerCase();
        const cap = word[0] === word[0].toUpperCase();
        let result;
        if (/^[aeiou]/.test(lower)) {
          result = lower + "way";
        } else {
          const m = lower.match(/^([^aeiou]+)(.*)/);
          result = m ? m[2] + m[1] + "ay" : lower + "ay";
        }
        return cap ? result[0].toUpperCase() + result.slice(1) : result;
      });
    }
  },
  {
    name: "Morse Code", native: "-- --- Â·-Â· Â·Â·Â· Â·", isFun: true,
    encode(text) {
      return text.toUpperCase().split("").map(c =>
        MORSE_MAP[c] || (c === " " ? "/" : c)
      ).join(" ");
    }
  },
  {
    name: "NATO Phonetic", native: "Alfa Bravo Charlie", isFun: true,
    encode(text) {
      return text.toUpperCase().split("").map(c =>
        NATO_MAP[c] || (c === " " ? " / " : c)
      ).join(" ");
    }
  },
  {
    name: "Braille", native: "â ƒâ —â â Šâ ‡â ‡â ‘", isFun: true,
    encode(text) {
      return [...text.toLowerCase()].map(c => {
        const i = c.charCodeAt(0) - 97;
        return (i >= 0 && i < 26) ? BRAILLE_MAP[i] : c;
      }).join("");
    }
  },
  {
    name: "Leet Speak", native: "1337", isFun: true,
    encode(text) {
      const map = {a:"4",e:"3",i:"1",o:"0",s:"5",t:"7",l:"1",g:"9"};
      return [...text].map(c => map[c.toLowerCase()] || c).join("");
    }
  },
  {
    name: "Backwards", native: "sdrawkcaB", isFun: true,
    encode(text) {
      return text.split(/(\s+)/).map(part =>
        /^\s+$/.test(part) ? part : [...part].reverse().join("")
      ).join("");
    }
  },
  {
    name: "ROT13", native: "EBG13", isFun: true,
    encode(text) {
      return text.replace(/[a-z]/gi, c => {
        const base = c <= "Z" ? 65 : 97;
        return String.fromCharCode(((c.charCodeAt(0) - base + 13) % 26) + base);
      });
    }
  },
  {
    name: "Ransom Note", native: "âœ‚ï¸ðŸ“°", isFun: true,
    _styles: [
      [0x1D400, 0x1D41A],  // Bold Serif
      [0x1D468, 0x1D482],  // Bold Italic
      [0x1D4D0, 0x1D4EA],  // Script Bold
      [0x1D56C, 0x1D586],  // Bold Fraktur
      [0x1D5D4, 0x1D5EE],  // Sans Bold
      [0x1D670, 0x1D68A],  // Monospace
      [0xFF21,  0xFF41],    // Fullwidth
      [0x24B6,  0x24D0],   // Circled
    ],
    _styledChar(c) {
      const code = c.codePointAt(0);
      const s = this._styles[Math.floor(Math.random() * this._styles.length)];
      if (code >= 65 && code <= 90)  return String.fromCodePoint(s[0] + code - 65);
      if (code >= 97 && code <= 122) return String.fromCodePoint(s[1] + code - 97);
      return c;
    },
    encode(text) {
      return [...text].map(c => this._styledChar(c)).join("");
    },
    encodeHtml(text) {
      const sizes = [0.7, 0.85, 1, 1.2, 1.4, 1.65];
      return text.split(/(\s+)/).map(part => {
        if (/^\s+$/.test(part)) return " ";
        const size = sizes[Math.floor(Math.random() * sizes.length)];
        const rot = (Math.random() * 10 - 5).toFixed(1);
        const letters = [...part].map(c => {
          const code = c.codePointAt(0);
          if ((code >= 65 && code <= 90) || (code >= 97 && code <= 122)) return this._styledChar(c);
          return c.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }).join("");
        return `<span style="display:inline-block;font-size:${size}em;transform:rotate(${rot}deg);vertical-align:middle;margin:0 0.05em">${letters}</span>`;
      }).join("");
    }
  },
  {
    name: "GeoCities", native: "ðŸš§ Under Construction", isFun: true,
    _colors: ["lime","red","blue","magenta","cyan","yellow","hotpink","purple","orange","maroon","navy","green","deeppink","aqua"],
    _faces: ["Comic Sans MS","Papyrus","Times New Roman","Courier New","Impact","Arial Black"],
    _sizes: ["2","3","4","5","6","7"],
    _marquees: ["scroll","alternate","slide"],
    encode(text) {
      const c = this._colors[Math.floor(Math.random() * this._colors.length)];
      const f = this._faces[Math.floor(Math.random() * this._faces.length)];
      return `<marquee><font color="${c}" face="${f}"><b><blink>${text}</blink></b></font></marquee>`;
    },
    encodeHtml(text) {
      const words = text.split(/(\s+)/);
      let html = words.map(part => {
        if (/^\s+$/.test(part)) return " ";
        const safe = escapeHtml(part);
        const color = this._colors[Math.floor(Math.random() * this._colors.length)];
        const face = this._faces[Math.floor(Math.random() * this._faces.length)];
        const size = this._sizes[Math.floor(Math.random() * this._sizes.length)];
        let inner = safe;
        if (Math.random() < 0.4) inner = `<b>${inner}</b>`;
        if (Math.random() < 0.3) inner = `<i>${inner}</i>`;
        if (Math.random() < 0.3) inner = `<u>${inner}</u>`;
        if (Math.random() < 0.2) inner = `<s>${inner}</s>`;
        if (Math.random() < 0.25) inner = `<blink>${inner}</blink>`;
        if (Math.random() < 0.15) inner = `<sub>${inner}</sub>`;
        else if (Math.random() < 0.15) inner = `<sup>${inner}</sup>`;
        return `<font color="${color}" face="${face}" size="${size}">${inner}</font>`;
      }).join("");
      if (Math.random() < 0.4) {
        const behavior = this._marquees[Math.floor(Math.random() * this._marquees.length)];
        const dir = Math.random() < 0.5 ? "left" : "right";
        html = `<marquee behavior="${behavior}" direction="${dir}" scrollamount="${2 + Math.floor(Math.random() * 4)}">${html}</marquee>`;
      }
      return html;
    }
  },
  {
    name: "Spongebob", native: "sPoNgEbOb", isFun: true,
    encode(text) {
      let upper = false;
      return [...text].map(c => {
        if (/[a-z]/i.test(c)) { upper = !upper; return upper ? c.toUpperCase() : c.toLowerCase(); }
        return c;
      }).join("");
    }
  },
  {
    name: "Upside Down", native: "uÊop Çpá´‰sdâˆ©", isFun: true,
    _map: {a:"É",b:"q",c:"É”",d:"p",e:"Ç",f:"ÉŸ",g:"Æƒ",h:"É¥",i:"á´‰",j:"É¾",k:"Êž",l:"l",m:"É¯",n:"u",o:"o",p:"d",q:"b",r:"É¹",s:"s",t:"Ê‡",u:"n",v:"ÊŒ",w:"Ê",x:"x",y:"ÊŽ",z:"z",A:"âˆ€",B:"ê“­",C:"Æ†",D:"ê“·",E:"ÆŽ",F:"â„²",G:"â…",H:"H",I:"I",J:"Å¿",K:"ê“˜",L:"Ë¥",M:"W",N:"N",O:"O",P:"Ô€",Q:"ê¹",R:"ê“¤",S:"S",T:"âŠ¥",U:"âˆ©",V:"Î›",W:"M",X:"X",Y:"â…„",Z:"Z","1":"Æ–","2":"á„…","3":"Æ","4":"ã„£","5":"Ï›","6":"9","7":"â±¢","8":"8","9":"6","0":"0",".":"Ë™",",":"'","?":"Â¿","!":"Â¡","'":",",'(':')',')':'('},
    encode(text) {
      return [...text].map(c => this._map[c] || c).reverse().join("");
    }
  },
];

const phraseEl    = document.getElementById("phrase");
const startLangEl = document.getElementById("startLang");
const stepsEl     = document.getElementById("steps");
const stepsValEl  = document.getElementById("stepsVal");
const goBtn       = document.getElementById("goBtn");
const goBtnText   = document.getElementById("goBtnText");
const chainEl     = document.getElementById("chain");
const resultEl    = document.getElementById("result");
const errorEl     = document.getElementById("error");
const resetBtn    = document.getElementById("resetBtn");

LANGUAGES.forEach(lang => {
  const opt = document.createElement("option");
  opt.value = lang.code;
  opt.textContent = `${lang.name} (${lang.native})`;
  startLangEl.appendChild(opt);
});

const browserLang = (navigator.language || "en").split("-")[0].toLowerCase();
const hasMatch = LANGUAGES.some(l => l.code === browserLang);
startLangEl.value = hasMatch ? browserLang : "en";

let running = false;
let abortCtrl = null;
let chainLog = [];

stepsEl.addEventListener("input", () => { stepsValEl.textContent = stepsEl.value; });

goBtn.addEventListener("click", () => {
  if (running) { abortCtrl?.abort(); return; }
  startChain();
});

resetBtn.addEventListener("click", () => {
  if (running) { abortCtrl?.abort(); }
  speechSynthesis.cancel();
  chainEl.innerHTML = "";
  resultEl.innerHTML = "";
  errorEl.innerHTML = "";
  resetBtn.style.display = "none";
  phraseEl.value = "";
  phraseEl.focus();
  phraseEl.scrollIntoView({ behavior: "smooth", block: "center" });
});

function pickRandomSteps(count, excludeCode) {
  const steps = [];

  if (excludeCode === "en") {
    const maxFun = Math.max(1, Math.floor(count / 4));
    const funCount = Math.floor(Math.random() * (maxFun + 1));
    const funPool = [...FUN_ENCODINGS];
    for (let i = 0; i < funCount && funPool.length; i++) {
      const idx = Math.floor(Math.random() * funPool.length);
      steps.push(funPool.splice(idx, 1)[0]);
    }
  }

  const langPool = LANGUAGES.filter(l => l.code !== excludeCode);
  const remaining = count - steps.length;
  for (let i = 0; i < remaining && langPool.length; i++) {
    const idx = Math.floor(Math.random() * langPool.length);
    steps.push(langPool.splice(idx, 1)[0]);
  }

  return steps;
}

class RateLimitError extends Error {
  constructor() { super("Rate limited"); this.name = "RateLimitError"; }
}

async function translate(text, from, to, signal) {
  const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${from}|${to}`;
  const resp = await fetch(url, { signal });
  if (resp.status === 429) throw new RateLimitError();
  if (!resp.ok) throw new Error(`API returned ${resp.status}`);
  const data = await resp.json();
  if (data.responseStatus === 429 || data.responseStatus === "429") throw new RateLimitError();
  if (data.responseStatus !== 200 && data.responseStatus !== "200") {
    throw new Error(data.responseDetails || "Translation failed");
  }
  return data.responseData.translatedText;
}

let voicesReady = false;
let cachedVoices = [];

function loadVoices() {
  cachedVoices = speechSynthesis.getVoices();
  if (cachedVoices.length) voicesReady = true;
}

function waitForVoices() {
  if (voicesReady) return Promise.resolve();
  return new Promise(resolve => {
    loadVoices();
    if (voicesReady) return resolve();
    const onchange = () => { loadVoices(); resolve(); };
    speechSynthesis.addEventListener("voiceschanged", onchange, { once: true });
    setTimeout(() => { loadVoices(); resolve(); }, 2000);
  });
}

function hasVoiceForLang(langCode) {
  return cachedVoices.some(v => v.lang === langCode || v.lang.startsWith(langCode + "-"));
}

function speak(text, langCode) {
  speechSynthesis.cancel();
  const utter = new SpeechSynthesisUtterance(text);
  utter.lang = langCode;
  const match = cachedVoices.find(v => v.lang.startsWith(langCode));
  if (match) utter.voice = match;
  speechSynthesis.speak(utter);
}

function addStepCard(langName, langNative, langCode, text, index, htmlContent) {
  if (chainEl.children.length > 0) {
    const conn = document.createElement("div");
    conn.className = "connector";
    conn.textContent = "â†“";
    chainEl.appendChild(conn);
  }

  const card = document.createElement("div");
  card.className = "step";
  card.style.animationDelay = `${index * 0.05}s`;

  const canSpeak = hasVoiceForLang(langCode);
  card.innerHTML = `
    <div class="step-header">
      <span class="lang-label">${langName}<span class="lang-native">${langNative}</span></span>
      <button class="speak-btn" title="Listen" ${canSpeak ? "" : "disabled"}>&#x1f50a;</button>
    </div>
    <div class="step-text">${htmlContent || escapeHtml(text)}</div>
  `;

  card.querySelector(".speak-btn").addEventListener("click", () => speak(text, langCode));
  chainEl.appendChild(card);
}

function showResult(original, final) {
  const diff = Diff.diffWords(original.toLowerCase(), final.toLowerCase());

  let html = "";
  let same = 0, total = 0;
  for (const part of diff) {
    const words = part.value.trim().split(/\s+/).filter(Boolean).length;
    total += words;
    if (!part.added && !part.removed) {
      same += words;
      html += escapeHtml(part.value);
    } else if (part.removed) {
      html += `<span class="removed">${escapeHtml(part.value)}</span>`;
    } else {
      html += `<span class="added">${escapeHtml(part.value)}</span>`;
    }
  }

  const pct = total > 0 ? Math.round((same / total) * 100) : 0;

  const conn = document.createElement("div");
  conn.className = "connector";
  conn.textContent = "â†“";
  chainEl.appendChild(conn);

  const steps = chainLog.map(s => `${s.lang}: ${s.text}`).join("\n\n");
  const shareUrl = buildShareUrl(original, chainLog.length, startLangEl.value);
  const summaryText = `${toBold(original)}\n\n${steps}\n\n${toBold(final)}\n\n${pct}% similarity\n\nTry it: ${shareUrl}`;

  resultEl.innerHTML = `
    <div class="result-card">
      <h2>Final vs. Original</h2>
      <div class="diff-display">${html}</div>
      <span class="similarity">${pct}%</span>
      <span class="similarity-label">word similarity</span>
      <br>
      <button class="copy-btn" id="copyBtn">&#x1f4cb; Copy for texting</button>
    </div>
  `;

  document.getElementById("copyBtn").addEventListener("click", async (e) => {
    try {
      await navigator.clipboard.writeText(summaryText);
      const btn = e.currentTarget;
      btn.classList.add("copied");
      btn.innerHTML = "&#x2705; Copied!";
      setTimeout(() => { btn.classList.remove("copied"); btn.innerHTML = "&#x1f4cb; Copy for texting"; }, 2000);
    } catch { /* clipboard not available */ }
  });
}

function buildShareUrl(phrase, steps, lang) {
  const url = new URL(window.location.href.split("?")[0]);
  url.searchParams.set("phrase", phrase);
  url.searchParams.set("steps", steps);
  if (lang !== "en") url.searchParams.set("lang", lang);
  return url.toString();
}

function sanitizeInput(raw) {
  if (typeof raw !== "string") return "";
  const stripped = raw.replace(/<[^>]*>/g, "").trim();
  return stripped.slice(0, 500);
}

function toBold(str) {
  return [...str].map(c => {
    const code = c.codePointAt(0);
    if (code >= 65 && code <= 90)  return String.fromCodePoint(code - 65 + 0x1D5D4);  // bold sans A-Z
    if (code >= 97 && code <= 122) return String.fromCodePoint(code - 97 + 0x1D5EE);  // bold sans a-z
    if (code >= 48 && code <= 57)  return String.fromCodePoint(code - 48 + 0x1D7EC);  // bold sans 0-9
    return c;
  }).join("");
}

function escapeHtml(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
}

function setRunning(state) {
  running = state;
  phraseEl.disabled = state;
  stepsEl.disabled = state;
  startLangEl.disabled = state;
  goBtnText.textContent = state ? "Stop" : "Start";
}

function delay(ms, signal) {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(resolve, ms);
    signal?.addEventListener("abort", () => { clearTimeout(timer); reject(new DOMException("Aborted", "AbortError")); });
  });
}

async function startChain() {
  const original = phraseEl.value.trim();
  if (!original) { phraseEl.focus(); return; }

  chainEl.innerHTML = "";
  resultEl.innerHTML = "";
  errorEl.innerHTML = "";

  abortCtrl = new AbortController();
  setRunning(true);
  resetBtn.style.display = "";

  await waitForVoices();

  const startCode = startLangEl.value;
  const startLang = LANGUAGES.find(l => l.code === startCode);
  const startName = startLang ? startLang.name : "English";
  const startNative = startLang ? startLang.native : "English";

  const count = parseInt(stepsEl.value, 10);
  const steps = pickRandomSteps(count, startCode);

  try {
    chainLog = [];
    addStepCard(startName, startNative + " Â· Start", startCode, original, 0);

    let current = original;
    let fromCode = startCode;
    let rateLimited = false;
    let stepIndex = 0;

    for (let i = 0; i < steps.length; i++) {
      const step = steps[i];
      await delay(350, abortCtrl.signal);

      if (step.isFun) {
        const encoded = step.encode(current);
        const html = step.encodeHtml ? step.encodeHtml(current) : null;
        addStepCard(step.name, step.native, "", encoded, i + 1, html);
        chainLog.push({ lang: step.name, text: encoded });
      } else {
        try {
          current = await translate(current, fromCode, step.code, abortCtrl.signal);
        } catch (e) {
          if (e instanceof RateLimitError) { rateLimited = true; break; }
          throw e;
        }
        addStepCard(step.name, step.native, step.code, current, i + 1);
        chainLog.push({ lang: step.name, text: current });
        fromCode = step.code;
      }
      stepIndex = i + 1;
    }

    if (rateLimited) {
      const usedNames = new Set(chainLog.map(s => s.lang));
      const unusedFun = FUN_ENCODINGS.filter(f => !usedNames.has(f.name));

      if (startCode === "en" && unusedFun.length) {
        errorEl.innerHTML = `<div class="error-msg">The translation API needs a breather! Filling in with some fun encodings instead.</div>`;
        for (const fun of unusedFun) {
          await delay(350, abortCtrl.signal);
          stepIndex++;
          const encoded = fun.encode(current);
          const html = fun.encodeHtml ? fun.encodeHtml(current) : null;
          addStepCard(fun.name, fun.native, "", encoded, stepIndex, html);
          chainLog.push({ lang: fun.name, text: encoded });
        }
      } else {
        errorEl.innerHTML = `<div class="error-msg">The translation API needs a breather! Skipping ahead to the final step with what we have so far.</div>`;
      }
    }

    await delay(350, abortCtrl.signal);
    let finalText;
    try {
      finalText = await translate(current, fromCode, startCode, abortCtrl.signal);
    } catch (e) {
      if (e instanceof RateLimitError) {
        if (fromCode === startCode) {
          finalText = current;
        } else {
          errorEl.innerHTML = `<div class="error-msg">The translation API needs a breather! Try again in a minute or use fewer steps.</div>`;
          return;
        }
      } else {
        throw e;
      }
    }
    addStepCard(startName, startNative + " Â· Final", startCode, finalText, stepIndex + 1);

    showResult(original, finalText);
  } catch (err) {
    if (err.name === "AbortError") {
      /* user cancelled */
    } else {
      errorEl.innerHTML = `<div class="error-msg">Something went wrong: ${escapeHtml(err.message)}</div>`;
    }
  } finally {
    setRunning(false);
  }
}

loadVoices();
speechSynthesis.addEventListener?.("voiceschanged", loadVoices);

const params = new URLSearchParams(window.location.search);
const initPhrase = sanitizeInput(params.get("phrase"));
if (initPhrase) {
  phraseEl.value = initPhrase;
}
const initSteps = parseInt(params.get("steps"), 10);
const minSteps = parseInt(stepsEl.min, 10);
const maxSteps = parseInt(stepsEl.max, 10);
if (initSteps >= minSteps && initSteps <= maxSteps) {
  stepsEl.value = initSteps;
  stepsValEl.textContent = initSteps;
}
const initLang = params.get("lang");
if (initLang && LANGUAGES.some(l => l.code === initLang)) {
  startLangEl.value = initLang;
}
</script>
</body>
</html>
